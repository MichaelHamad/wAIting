# Waiting - MVP Implementation Plan

**Author:** Senior Engineer Agent
**Date:** 2026-01-10
**Status:** Ready for Development
**Branch:** mvp-fresh-start

---

## Executive Summary

This document details the phased implementation strategy for the **Waiting** audio notification system - a Python-based tool that plays bell sounds when Claude Code permission dialogs go unresponded. The MVP is designed around three core pillars:

1. **Hook-driven event detection** (via Claude Code's PermissionRequest/PreToolUse hooks)
2. **Cross-platform audio playback** (Linux, macOS, WSL with fallback chain)
3. **Simple state management** (temp files for session tracking)

The implementation uses **functional TypeScript-style Python** with strict type hints, test-first development, and small, focused commits.

---

## Phase Overview

```
Phase 1: Foundation      (Weeks 1-2)  → Core structure, config, tests
Phase 2: Hooks & Events  (Week 2-3)   → Hook scripts, state management
Phase 3: Audio Playback  (Week 3-4)   → Cross-platform audio, integration
Phase 4: CLI Commands    (Week 4)     → Install/enable/disable/status
Phase 5: Testing & QA    (Week 5)     → E2E tests, platform validation
```

---

## Project Structure

```
waiting_new/
├── src/waiting/
│   ├── __init__.py                         # Package init
│   ├── __main__.py                         # CLI entry point
│   ├── cli.py                              # Command handlers (enable/disable/status)
│   ├── config.py                           # Configuration loading/validation
│   ├── audio.py                            # Audio playback abstraction
│   ├── audio_players/
│   │   ├── __init__.py
│   │   ├── base.py                         # AudioPlayer protocol/abstract base
│   │   ├── linux.py                        # PulseAudio, PipeWire, ALSA
│   │   ├── macos.py                        # afplay
│   │   └── windows.py                      # PowerShell fallback
│   ├── hooks/
│   │   ├── __init__.py
│   │   ├── manager.py                      # Hook installation/removal
│   │   ├── scripts/
│   │   │   ├── waiting-notify-permission.sh
│   │   │   └── waiting-activity-tooluse.sh
│   ├── state.py                            # Temp file state management
│   ├── logging.py                          # Logging configuration
│   └── errors.py                           # Custom exceptions
├── tests/
│   ├── __init__.py
│   ├── conftest.py                         # Pytest fixtures
│   ├── unit/
│   │   ├── test_config.py
│   │   ├── test_audio.py
│   │   ├── test_audio_players.py
│   │   ├── test_state.py
│   │   └── test_hooks.py
│   └── integration/
│       ├── test_cli.py
│       ├── test_hook_lifecycle.py
│       └── test_audio_playback.py
├── hooks/                                  # Generated hooks (not committed)
│   ├── waiting-notify-permission.sh        # Generated by hook manager
│   └── waiting-activity-tooluse.sh         # Generated by hook manager
├── pyproject.toml                          # Package metadata
├── pytest.ini                              # Pytest config
└── .gitignore                              # Exclude venv, .pyc, hooks/

Key Files Generated at Runtime:
~/.waiting.json                             # User config (on first enable)
~/.claude/hooks/waiting-*.sh               # Installed hooks
/tmp/waiting-stop-{session_id}             # Stop signal file
/tmp/waiting-audio-{session_id}.pid        # Audio process PID
~/.waiting.log                             # Debug log
```

---

## Architecture & Design Patterns

### 1. Functional Style + Strict TypeScript

All modules will use:
- **Type hints on all functions** (Parameter: Type -> Return: Type)
- **No mutable global state** (dependency injection)
- **Pure functions where possible** (deterministic, no side effects)
- **Protocol-based polymorphism** (audio player strategies)
- **Exceptions for error handling** (custom exception types)

Example:
```python
# Good: Pure function
def validate_grace_period(value: int) -> tuple[bool, str | None]:
    """Returns (is_valid, error_message)"""
    if value <= 0:
        return False, "grace_period must be positive"
    return True, None

# Good: Dependency injection
def play_audio(
    audio_player: AudioPlayer,
    file_path: str,
    volume: int
) -> int:  # Returns PID
    """Play audio and return process ID"""
    pass

# Avoid: Mutable global state
# BAD: config = load_config()  # Global
```

### 2. Hook Management Strategy

**Two-hook approach:**

| Hook | Trigger | Action |
|------|---------|--------|
| `waiting-notify-permission.sh` | `PermissionRequest` | Start grace period, play audio if no signal |
| `waiting-activity-tooluse.sh` | `PreToolUse` | Create stop signal (user responded) |

**Hook Installation Flow:**
1. User runs `waiting` → CLI calls `HookManager.install()`
2. `HookManager` generates hook scripts from templates
3. Scripts written to `~/.claude/hooks/waiting-*.sh` with execute permissions
4. User restarts Claude Code → hooks take effect

**State Communication:**
- Hooks communicate via `/tmp` files (cross-process, simple, reliable)
- Session ID extracted from Claude's JSON hook input or MD5 hash fallback

### 3. Audio Playback Strategy (Strategy Pattern)

```python
Protocol AudioPlayer:
    def play(file_path: str, volume: int) -> int:  # Returns PID
        ...
    def kill(pid: int) -> bool:
        ...
    def available() -> bool:
        ...
    def name() -> str:
        ...
```

**Fallback Chain (Linux):**
1. Try `paplay` (PulseAudio - most common)
2. Try `pw-play` (PipeWire - newer systems)
3. Try `aplay` (ALSA - fallback)
4. Log warning, continue gracefully

**Per-platform:**
- Linux: Fallback chain (paplay → pw-play → aplay)
- macOS: `afplay`
- WSL: PowerShell audio

### 4. State Management via Temp Files

**Why temp files?**
- No database needed (MVP simplicity)
- No process-local state (hooks are separate processes)
- Atomic operations via file existence checks
- Self-cleaning (old files auto-pruned)

**State Files:**
```
/tmp/waiting-stop-{session_id}
  - Existence signals "user responded"
  - Created by activity hook
  - Deleted after permission hook checks it

/tmp/waiting-audio-{session_id}.pid
  - Contains audio process PID
  - Created by permission hook before audio
  - Read by activity hook to kill process
  - Deleted after audio completes
```

**Session ID:**
- Extracted from Claude's hook JSON: `hook_input.session_id`
- Fallback: MD5(hostname + timestamp)
- Unique per permission dialog

### 5. Configuration Management

**File:** `~/.waiting.json`

```json
{
  "grace_period": 30,
  "volume": 100,
  "audio": "default"
}
```

**Validation:**
- Loaded on first `waiting` command
- Validated on each hook execution
- Invalid config → use defaults + warning log
- User can edit manually anytime

**Defaults:**
```python
DEFAULT_CONFIG = {
    "grace_period": 30,      # seconds, positive int
    "volume": 100,           # 1-100
    "audio": "default"       # "default" or file path
}
```

---

## Critical Integration Point: Hook Registration

**IMPORTANT:** Hooks must be registered in `~/.claude/settings.json` to take effect. This is handled by the HookManager (Phase 2), but here's the format that will be written:

```json
{
  "hooks": {
    "PermissionRequest": [
      {
        "matcher": ".*",
        "hooks": [
          {
            "type": "command",
            "command": "~/.claude/hooks/waiting-notify-permission.sh"
          }
        ]
      }
    ],
    "PreToolUse": [
      {
        "matcher": ".*",
        "hooks": [
          {
            "type": "command",
            "command": "~/.claude/hooks/waiting-activity-tooluse.sh"
          }
        ]
      }
    ]
  }
}
```

**Key Points:**
- Hooks receive JSON input via stdin with fields: `session_id`, `transcript_path`, `cwd`, `permission_mode`, `hook_event_name`
- Hook output (exit code 0) can include JSON for structured responses
- `PermissionRequest` hook receives JSON with `decision.behavior` field (allow/deny/ask)
- `PreToolUse` hook can output JSON with `hookSpecificOutput.permissionDecision`
- Exit codes: 0 = success, 2 = blocking error (stderr shown), other = non-blocking error

---

## Phase 1: Foundation (Weeks 1-2)

### Goals
- Establish project structure
- Implement config management
- Build logging infrastructure
- Create unit test framework

### Tasks

#### 1.1: Project Setup & Dependencies
- **File:** `/home/michael/projects/waiting_new/pyproject.toml`
- **Changes:**
  ```toml
  [project]
  name = "waiting"
  version = "0.1.0"
  scripts = { waiting = "waiting.__main__:main" }

  [tool.pytest.ini_options]
  testpaths = ["tests"]
  ```
- **Why:** Declares CLI entry point and test config
- **Acceptance:** `pip install -e .` works, `waiting --help` runs

#### 1.2: Core Package Structure
- **Files to create:**
  - `/home/michael/projects/waiting_new/src/waiting/__main__.py` (CLI entry)
  - `/home/michael/projects/waiting_new/src/waiting/errors.py` (custom exceptions)
  - `/home/michael/projects/waiting_new/src/waiting/logging.py` (log setup)

- **`errors.py` - Custom Exceptions:**
  ```python
  class WaitingError(Exception):
      """Base exception"""
      pass

  class ConfigError(WaitingError):
      """Configuration validation errors"""
      pass

  class HookError(WaitingError):
      """Hook installation/removal errors"""
      pass

  class AudioError(WaitingError):
      """Audio playback errors"""
      pass
  ```

- **`logging.py` - Logging Setup:**
  ```python
  import logging
  from pathlib import Path

  def setup_logging() -> logging.Logger:
      """Configure logging to ~/.waiting.log"""
      log_path = Path.home() / ".waiting.log"
      handler = logging.FileHandler(log_path)
      # ... configure formatter, level
      return logger
  ```

- **Acceptance:**
  - `import waiting.errors` succeeds
  - Logs written to `~/.waiting.log`

#### 1.3: Configuration Module (`config.py`)
- **File:** `/home/michael/projects/waiting_new/src/waiting/config.py`
- **Type-safe config loading:**
  ```python
  from dataclasses import dataclass
  from pathlib import Path
  import json

  @dataclass(frozen=True)
  class Config:
      grace_period: int
      volume: int
      audio: str

      def validate(self) -> tuple[bool, str | None]:
          """Returns (is_valid, error_message)"""
          # Validation logic
          pass

  def load_config(config_path: Path | None = None) -> Config:
      """Load from ~/.waiting.json or create defaults"""
      pass

  def save_config(config: Config, path: Path | None = None) -> None:
      """Save to ~/.waiting.json"""
      pass
  ```

- **Tests:** (`tests/unit/test_config.py`)
  - Load default config
  - Load custom config
  - Validate valid configs
  - Reject invalid configs (negative grace_period, volume > 100, etc.)
  - Create config file on first load

- **Acceptance:**
  - Config loads with defaults if file missing
  - Invalid configs raise `ConfigError`
  - Config persists to `~/.waiting.json`

#### 1.4: State Management (`state.py`)
- **File:** `/home/michael/projects/waiting_new/src/waiting/state.py`
- **Temp file abstraction:**
  ```python
  from pathlib import Path
  import hashlib

  def generate_session_id(hook_input: dict) -> str:
      """Extract from JSON or generate fallback"""
      pass

  def write_pid_file(session_id: str, pid: int) -> Path:
      """Write /tmp/waiting-audio-{session}.pid"""
      pass

  def read_pid_file(session_id: str) -> int | None:
      """Read PID from file"""
      pass

  def create_stop_signal(session_id: str) -> Path:
      """Create /tmp/waiting-stop-{session}"""
      pass

  def has_stop_signal(session_id: str) -> bool:
      """Check if user responded"""
      pass

  def cleanup(session_id: str) -> None:
      """Remove all temp files for session"""
      pass

  def cleanup_old_files(age_hours: int = 1) -> None:
      """Auto-prune files older than N hours"""
      pass
  ```

- **Tests:** (`tests/unit/test_state.py`)
  - Generate session IDs from hook input
  - Fallback session ID generation
  - Write/read PID files
  - Create/detect stop signals
  - Cleanup removes files
  - Old files are pruned

- **Acceptance:**
  - Session IDs are unique and reproducible
  - Temp files created and cleaned up properly
  - Old files auto-pruned

#### 1.5: Test Framework Setup
- **File:** `/home/michael/projects/waiting_new/tests/conftest.py`
- **Pytest fixtures:**
  ```python
  import pytest
  from pathlib import Path
  import tempfile

  @pytest.fixture
  def tmp_config_dir(tmp_path):
      """Temporary config directory"""
      return tmp_path

  @pytest.fixture
  def tmp_home(tmp_path, monkeypatch):
      """Mock home directory"""
      monkeypatch.setenv("HOME", str(tmp_path))
      return tmp_path
  ```

- **File:** `/home/michael/projects/waiting_new/pytest.ini`
  ```ini
  [pytest]
  testpaths = tests
  python_files = test_*.py
  addopts = -v --tb=short
  ```

- **Acceptance:**
  - `pytest tests/` runs all tests
  - Fixtures provide isolated test environments

#### 1.6: Settings Integration Module (`settings.py`) [NEW - CRITICAL FOR HOOKS]
- **File:** `/home/michael/projects/waiting_new/src/waiting/settings.py`
- **Responsibilities:**
  ```python
  from pathlib import Path
  import json
  from typing import Any

  def load_settings(settings_path: Path | None = None) -> dict[str, Any]:
      """Load ~/.claude/settings.json"""
      pass

  def save_settings(settings: dict[str, Any], settings_path: Path | None = None) -> None:
      """Save to ~/.claude/settings.json"""
      pass

  def merge_hooks_into_settings(
      settings: dict[str, Any],
      new_hooks: dict[str, list]
  ) -> dict[str, Any]:
      """Merge waiting hooks into existing settings.hooks"""
      # Preserve existing hooks, add/update waiting hooks
      pass

  def remove_hooks_from_settings(
      settings: dict[str, Any]
  ) -> dict[str, Any]:
      """Remove waiting hooks from settings"""
      pass
  ```

- **Why:** Official Hook specs require hooks to be registered in `~/.claude/settings.json`. This module provides the integration layer.

- **Tests:** (`tests/unit/test_settings.py`)
  - Load settings from file
  - Save settings to file
  - Merge hooks without destroying existing hooks
  - Remove hooks cleanly
  - Handle missing settings file gracefully
  - Preserve user settings when modifying hooks

- **Acceptance:**
  - Settings load/save works
  - Hook registration doesn't overwrite other hooks
  - Hook removal is clean and idempotent
  - `~/.claude/settings.json` created if missing

---

## Phase 2: Hooks & Events (Weeks 2-3)

### Goals
- Build hook manager for installation/removal
- Implement hook script generation
- Create state synchronization between hooks
- Test hook lifecycle

### Tasks

#### 2.1: Hook Manager (`hooks/manager.py`) [UPDATED FOR SETTINGS INTEGRATION]
- **File:** `/home/michael/projects/waiting_new/src/waiting/hooks/manager.py`
- **Responsibilities:**
  ```python
  from pathlib import Path
  from waiting.config import Config
  from waiting.settings import load_settings, save_settings, merge_hooks_into_settings

  class HookManager:
      def install(config: Config) -> None:
          """
          1. Generate hook scripts to ~/.claude/hooks/
          2. Register hooks in ~/.claude/settings.json
          3. Restart Claude Code required for hooks to take effect
          """
          # Write hook scripts to ~/.claude/hooks/waiting-*.sh
          # Load ~/.claude/settings.json
          # Merge waiting hooks into settings.hooks.PermissionRequest and PreToolUse
          # Save updated settings back
          pass

      def remove() -> None:
          """
          1. Remove hook scripts from ~/.claude/hooks/
          2. Remove hook registration from ~/.claude/settings.json
          """
          # Delete hook scripts
          # Load ~/.claude/settings.json
          # Remove waiting hooks from settings
          # Save updated settings
          pass

      def is_installed() -> bool:
          """Check if hooks are registered in ~/.claude/settings.json"""
          pass

      def get_hook_paths() -> dict[str, Path]:
          """Return paths to hook scripts"""
          pass
  ```

- **Implementation Details:**
  - Hook scripts written to `~/.claude/hooks/` with `mode=0o755`
  - Hook **registration** written to `~/.claude/settings.json` (CRITICAL)
  - Create `~/.claude/hooks/` and `~/.claude/` if missing
  - Settings merge must preserve existing hooks from other tools
  - Gracefully handle missing settings.json (create with waiting hooks)

- **Hook Registration Format (written to settings.json):**
  ```json
  {
    "hooks": {
      "PermissionRequest": [
        {
          "matcher": ".*",
          "hooks": [{
            "type": "command",
            "command": "~/.claude/hooks/waiting-notify-permission.sh"
          }]
        }
      ],
      "PreToolUse": [
        {
          "matcher": ".*",
          "hooks": [{
            "type": "command",
            "command": "~/.claude/hooks/waiting-activity-tooluse.sh"
          }]
        }
      ]
    }
  }
  ```

- **Acceptance:**
  - Hooks installed to correct path
  - Hooks are executable
  - Settings.json properly registered
  - Removal cleans both scripts and registration
  - Existing hooks preserved during merge
  - Idempotent (safe to call multiple times)

#### 2.2: Hook Scripts - Permission Handler [UPDATED WITH JSON RESPONSE]
- **File:** `/home/michael/projects/waiting_new/src/waiting/hooks/scripts/waiting-notify-permission.sh`
- **Bash script triggered by PermissionRequest event**
- **Responsibilities:**
  1. Read Claude's hook JSON input from stdin
  2. Load config from `~/.waiting.json`
  3. Extract/generate session ID from hook input
  4. Start grace period timer (background sleep)
  5. Monitor for stop signal file
  6. If timer expires, play audio
  7. Clean up temp files
  8. Return JSON response to allow/deny (optional for PermissionRequest)

- **Important Hook Details:**
  - **Hook Input:** JSON via stdin with fields: `session_id`, `transcript_path`, `cwd`, `permission_mode`, `hook_event_name`
  - **Hook Output:** JSON response format for PermissionRequest:
    ```json
    {
      "hookSpecificOutput": {
        "hookEventName": "PermissionRequest",
        "decision": {
          "behavior": "allow" | "deny" | "ask"
        }
      }
    }
    ```
  - **Exit Code:** 0 = success (JSON processed), 2 = blocking error

- **Pseudo-code:**
  ```bash
  #!/bin/bash
  set -e

  # Read hook input from stdin
  HOOK_JSON=$(cat)

  # Parse session ID - official hook spec provides this
  SESSION_ID=$(echo "$HOOK_JSON" | jq -r '.session_id // empty' 2>/dev/null || echo "")

  # Fallback: generate MD5 session ID if not provided
  if [ -z "$SESSION_ID" ]; then
    SESSION_ID=$(echo "$(hostname)-$(date +%s%N)" | md5sum | cut -d' ' -f1)
  fi

  # Load config from ~/.waiting.json
  CONFIG_FILE="$HOME/.waiting.json"
  if [ ! -f "$CONFIG_FILE" ]; then
    # Config not found, exit gracefully (defaults will be used)
    exit 0
  fi

  GRACE_PERIOD=$(jq -r '.grace_period // 30' "$CONFIG_FILE" 2>/dev/null || echo "30")
  AUDIO_FILE=$(jq -r '.audio // "default"' "$CONFIG_FILE" 2>/dev/null || echo "default")
  VOLUME=$(jq -r '.volume // 100' "$CONFIG_FILE" 2>/dev/null || echo "100")

  STOP_SIGNAL="/tmp/waiting-stop-$SESSION_ID"
  PID_FILE="/tmp/waiting-audio-$SESSION_ID.pid"
  LOG_FILE="$HOME/.waiting.log"

  # Log event
  echo "[$(date)] PermissionRequest detected. Session: $SESSION_ID, Grace: ${GRACE_PERIOD}s" >> "$LOG_FILE"

  # Run grace period in background
  (
    for ((i=0; i<$GRACE_PERIOD; i++)); do
      if [ -f "$STOP_SIGNAL" ]; then
        # User responded (activity detected), exit early
        rm -f "$STOP_SIGNAL" "$PID_FILE"
        echo "[$(date)] User responded before grace period expired. Session: $SESSION_ID" >> "$LOG_FILE"
        exit 0
      fi
      sleep 1
    done

    # Grace period expired, no user response yet
    if [ ! -f "$STOP_SIGNAL" ]; then
      echo "[$(date)] Grace period expired. Playing audio. Session: $SESSION_ID" >> "$LOG_FILE"

      # Call Python audio player
      python3 -m waiting.audio.play "$AUDIO_FILE" "$VOLUME" > "$PID_FILE" 2>> "$LOG_FILE"
      AUDIO_PID=$(cat "$PID_FILE" 2>/dev/null || echo "")

      if [ -n "$AUDIO_PID" ]; then
        # Wait for audio process
        wait "$AUDIO_PID" 2>/dev/null || true
      fi
    fi

    # Cleanup temp files
    rm -f "$STOP_SIGNAL" "$PID_FILE"
  ) &

  # Hook exits immediately - grace period runs in background
  exit 0
  ```

- **Key Points (from official hook specs):**
  - Non-blocking - must exit immediately, grace period in background
  - Reads JSON input from stdin
  - `session_id` available in hook input (fallback to MD5 if not)
  - Graceful degradation if jq or config unavailable
  - Logs to `~/.waiting.log` for debugging
  - Can optionally return JSON response (currently just monitoring)

- **Acceptance:**
  - Script executes and exits immediately (non-blocking)
  - Parses session ID from official hook JSON input
  - Creates temp files for state coordination
  - Monitors for stop signal (from PreToolUse hook)
  - Plays audio only after grace period expires
  - Cleans up all temp files

#### 2.3: Hook Scripts - Activity Handler [UPDATED WITH CLARIFICATION]
- **File:** `/home/michael/projects/waiting_new/src/waiting/hooks/scripts/waiting-activity-tooluse.sh`
- **Bash script triggered by PreToolUse event**
- **Clarification:** This hook detects when the user attempts any tool use (not just response to permission dialog). It signals the permission hook that activity has occurred.
- **Responsibilities:**
  1. Extract session ID from hook JSON input
  2. Create stop signal file (indicates user activity)
  3. Kill audio process if it's running
  4. Exit cleanly

- **Important Hook Details (from official specs):**
  - **Hook Event:** `PreToolUse` - runs before ANY tool is executed
  - **Hook Input:** JSON with `session_id`, `tool_name`, `tool_input`, `tool_use_id`, etc.
  - **Note:** PreToolUse fires for every tool call (Read, Write, Edit, Bash, etc.), not just permission-related tools
  - This is intentional: any activity = user responded to permission request

- **Pseudo-code:**
  ```bash
  #!/bin/bash
  set -e

  # Read hook input from stdin
  HOOK_JSON=$(cat)

  # Parse session ID from hook input
  SESSION_ID=$(echo "$HOOK_JSON" | jq -r '.session_id // empty' 2>/dev/null || echo "")

  # Fallback: generate MD5 session ID if not provided
  if [ -z "$SESSION_ID" ]; then
    SESSION_ID=$(echo "$(hostname)-$(date +%s%N)" | md5sum | cut -d' ' -f1)
  fi

  STOP_SIGNAL="/tmp/waiting-stop-$SESSION_ID"
  PID_FILE="/tmp/waiting-audio-$SESSION_ID.pid"
  LOG_FILE="$HOME/.waiting.log"

  # Extract tool name for logging
  TOOL_NAME=$(echo "$HOOK_JSON" | jq -r '.tool_name // "unknown"' 2>/dev/null || echo "unknown")

  # User took action - signal permission hook to stop grace period
  touch "$STOP_SIGNAL"

  # Kill audio process if running
  if [ -f "$PID_FILE" ]; then
    AUDIO_PID=$(cat "$PID_FILE" 2>/dev/null)
    if [ -n "$AUDIO_PID" ]; then
      kill "$AUDIO_PID" 2>/dev/null || true
      rm -f "$PID_FILE"
      echo "[$(date)] Audio killed (PID: $AUDIO_PID). Session: $SESSION_ID" >> "$LOG_FILE"
    fi
  fi

  echo "[$(date)] User activity detected. Tool: $TOOL_NAME. Session: $SESSION_ID" >> "$LOG_FILE"

  # Hook exits immediately (non-blocking)
  exit 0
  ```

- **Key Points (from official hook specs):**
  - PreToolUse runs before EVERY tool call, so this detects any user activity
  - Non-blocking - must exit immediately
  - Reads JSON from stdin (same structure as PermissionRequest)
  - Creates signal file to coordinate with PermissionRequest hook
  - Kills audio process if it's still running

- **Acceptance:**
  - Creates stop signal file
  - Kills audio process if running
  - Cleans up PID file
  - Logs activity for debugging
  - Exits immediately without blocking

#### 2.4: Hook Installation Tests
- **File:** `/home/michael/projects/waiting_new/tests/unit/test_hooks.py`
- **Tests:**
  - Generate correct hook scripts
  - Install hooks to correct path
  - Remove hooks cleanly
  - Verify execute permissions
  - Detect existing hooks

- **File:** `/home/michael/projects/waiting_new/tests/integration/test_hook_lifecycle.py`
- **Integration Tests:**
  - Simulate PermissionRequest event
  - Verify permission hook executes
  - Simulate PreToolUse event
  - Verify activity hook stops audio
  - Check temp file cleanup

- **Acceptance:**
  - All hook unit tests pass
  - Hook lifecycle tests pass

#### 2.5: Future Hook: Notification Event (Out of Scope - Phase 6+)
- **File:** (Future) `/home/michael/projects/waiting_new/src/waiting/hooks/scripts/waiting-notification.sh`
- **Hook Event:** `Notification` (from official specs - line 348+)
- **Why not MVP:** Requires idle_prompt detection, which is a more complex feature
- **Future Use Case:** When Claude Code is idle (waiting for user input > 60s), fire notification hook to get user's attention
- **When to implement:** After core MVP working, as enhancement
- **Configuration:**
  ```json
  {
    "hooks": {
      "Notification": [
        {
          "matcher": "idle_prompt",
          "hooks": [{
            "type": "command",
            "command": "~/.claude/hooks/waiting-notification.sh"
          }]
        }
      ]
    }
  }
  ```
- **Note:** This is a different use case from PermissionRequest. PermissionRequest = permission dialog waiting. Notification = Claude waiting for user input. Both could benefit from bell notifications but are separate features.

---

## Phase 3: Audio Playback (Weeks 3-4)

### Goals
- Implement cross-platform audio playback
- Build strategy pattern for player selection
- Create platform detection logic
- Integrate audio with hooks

### Tasks

#### 3.1: Audio Player Protocol & Base Class
- **File:** `/home/michael/projects/waiting_new/src/waiting/audio_players/base.py`
- **Protocol definition:**
  ```python
  from typing import Protocol

  class AudioPlayer(Protocol):
      """Interface for audio playback"""

      def play(self, file_path: str, volume: int) -> int:
          """
          Play audio file.
          Args:
              file_path: Path to audio file (or "default" for system bell)
              volume: Volume 1-100
          Returns:
              Process ID of audio player
          Raises:
              AudioError if playback fails
          """
          ...

      def kill(self, pid: int) -> bool:
          """
          Kill audio process.
          Returns True if killed, False if already gone.
          """
          ...

      def available(self) -> bool:
          """Check if player command is available"""
          ...

      def name(self) -> str:
          """Player name for logging"""
          ...
  ```

#### 3.2: Linux Audio Players
- **File:** `/home/michael/projects/waiting_new/src/waiting/audio_players/linux.py`
- **Implement three players:**

  **PulseAudioPlayer:**
  ```python
  class PulseAudioPlayer:
      def play(file_path: str, volume: int) -> int:
          # Convert volume 1-100 to 0.0-1.0
          pa_volume = volume / 100.0
          cmd = ["paplay", "--volume", str(int(pa_volume * 65536))]
          if file_path != "default":
              cmd.append(file_path)
          else:
              cmd.extend(["--property", "media.role=alert"])
          # ... execute and return PID
  ```

  **PipeWirePlayer:** Similar structure, uses `pw-play`

  **ALSAPlayer:** Similar structure, uses `aplay`

- **Fallback Chain:**
  ```python
  def get_linux_player() -> AudioPlayer:
      """Return first available player"""
      for player_class in [PulseAudioPlayer, PipeWirePlayer, ALSAPlayer]:
          if player_class().available():
              return player_class()
      raise AudioError("No audio player available")
  ```

- **Acceptance:**
  - Each player implements protocol
  - Fallback chain works correctly
  - Volume conversion accurate

#### 3.3: macOS & Windows Audio Players
- **File:** `/home/michael/projects/waiting_new/src/waiting/audio_players/macos.py`
  ```python
  class AFPlayPlayer:
      def play(file_path: str, volume: int) -> int:
          cmd = ["afplay"]
          if file_path != "default":
              cmd.append(file_path)
          # afplay respects system default volume, but can use -v for volume
          cmd.extend(["-v", str(volume / 100.0)])
          # ... execute and return PID
  ```

- **File:** `/home/michael/projects/waiting_new/src/waiting/audio_players/windows.py`
  ```python
  class PowerShellPlayer:
      def play(file_path: str, volume: int) -> int:
          # PowerShell audio playback command
          # Requires special syntax for WSL
          ps_script = f"""
          $player = New-Object System.Media.SoundPlayer;
          $player.SoundLocation = '{file_path}';
          $player.Play();
          """
          # ... execute in PowerShell and return PID
  ```

- **Acceptance:**
  - macOS player uses afplay
  - Windows player uses PowerShell
  - Volume settings respected

#### 3.4: Audio Module & Platform Detection
- **File:** `/home/michael/projects/waiting_new/src/waiting/audio.py`
- **Main audio interface:**
  ```python
  import platform
  from pathlib import Path

  def get_audio_player() -> AudioPlayer:
      """Auto-detect and return appropriate player for platform"""
      system = platform.system()

      if system == "Linux":
          return get_linux_player()
      elif system == "Darwin":  # macOS
          return AFPlayPlayer()
      elif system == "Windows":
          return PowerShellPlayer()
      else:
          raise AudioError(f"Unsupported platform: {system}")

  def resolve_audio_file(audio_config: str) -> Path:
      """
      Resolve audio file path.
      If "default", return system bell path.
      Otherwise validate file exists.
      """
      if audio_config == "default":
          # System bell paths
          candidates = [
              Path("/usr/share/sounds/freedesktop/stereo/complete.oga"),
              Path("/System/Library/Sounds/Glass.aiff"),  # macOS
          ]
          for path in candidates:
              if path.exists():
                  return path
          return "default"  # Fallback to system bell

      audio_path = Path(audio_config).expanduser()
      if not audio_path.exists():
          raise AudioError(f"Audio file not found: {audio_config}")
      return audio_path

  def play_audio(
      file_path: str,
      volume: int,
      logger: logging.Logger
  ) -> int:
      """
      Play audio and return PID.
      Raises AudioError on failure.
      """
      try:
          player = get_audio_player()
          resolved_path = resolve_audio_file(file_path)
          pid = player.play(str(resolved_path), volume)
          logger.info(f"Audio playing with PID {pid} using {player.name()}")
          return pid
      except Exception as e:
          logger.error(f"Audio playback failed: {e}")
          raise AudioError(str(e)) from e

  def kill_audio(pid: int) -> bool:
      """Kill audio process by PID"""
      try:
          player = get_audio_player()
          return player.kill(pid)
      except:
          # Graceful fallback - try OS kill
          import subprocess
          subprocess.run(["kill", str(pid)], check=False)
          return True
  ```

- **CLI Sub-module for hook scripts:**
  ```python
  # src/waiting/audio.py - Add this for hook script use:
  if __name__ == "__main__":
      import sys
      file_path = sys.argv[1] if len(sys.argv) > 1 else "default"
      volume = int(sys.argv[2]) if len(sys.argv) > 2 else 100
      logger = setup_logging()
      pid = play_audio(file_path, volume, logger)
      print(pid)
  ```

- **Acceptance:**
  - Platform detection works
  - Audio file resolution works
  - Audio playback returns PID
  - Can be called from hook scripts

#### 3.5: Audio Player Tests
- **File:** `/home/michael/projects/waiting_new/tests/unit/test_audio_players.py`
- **Tests:**
  - Each player type available() check
  - Play command construction
  - Volume conversion
  - Process killing

- **File:** `/home/michael/projects/waiting_new/tests/unit/test_audio.py`
- **Tests:**
  - Platform detection
  - Audio file resolution (default vs custom)
  - Play audio returns PID
  - Invalid files raise AudioError

- **File:** `/home/michael/projects/waiting_new/tests/integration/test_audio_playback.py`
- **Integration tests:**
  - Actually play audio (mock in CI)
  - Kill audio process
  - Verify PID tracking

- **Acceptance:**
  - All audio tests pass
  - Platform-specific logic tested
  - Error handling verified

---

## Phase 4: CLI Commands (Week 4)

### Goals
- Implement command-line interface
- Build enable/disable/status commands
- Create user-facing output
- Test CLI end-to-end

### Tasks

#### 4.1: CLI Module
- **File:** `/home/michael/projects/waiting_new/src/waiting/cli.py`
- **Command handlers:**

  ```python
  import sys
  from pathlib import Path

  class CLI:
      def __init__(self, config_path: Path | None = None):
          self.config_path = config_path or (Path.home() / ".waiting.json")
          self.logger = setup_logging()

      def enable(self) -> int:
          """Enable notifications (install hooks)"""
          try:
              config = load_config(self.config_path)
              HookManager().install(config)
              print("✓ Waiting hooks installed to ~/.claude/hooks/")
              print("✓ Configuration: ~/.waiting.json")
              print("")
              print("Next steps:")
              print("  1. Restart Claude Code for hooks to take effect")
              print("  2. Trigger a permission dialog to test")
              return 0
          except Exception as e:
              print(f"✗ Error: {e}", file=sys.stderr)
              self.logger.error(f"Enable failed: {e}")
              return 1

      def disable(self) -> int:
          """Disable notifications (remove hooks)"""
          try:
              HookManager().remove()
              print("✓ Waiting hooks removed")
              print("✓ Configuration file preserved at ~/.waiting.json")
              return 0
          except Exception as e:
              print(f"✗ Error: {e}", file=sys.stderr)
              self.logger.error(f"Disable failed: {e}")
              return 1

      def status(self) -> int:
          """Show current configuration and status"""
          try:
              config = load_config(self.config_path)
              is_installed = HookManager().is_installed()

              print("Waiting - Audio Notification System")
              print("=" * 40)
              print(f"Status:         {'ENABLED' if is_installed else 'DISABLED'}")
              print(f"Grace Period:   {config.grace_period}s")
              print(f"Volume:         {config.volume}%")
              print(f"Audio:          {config.audio}")
              print(f"Config File:    {self.config_path}")
              print("")

              if is_installed:
                  print("Hooks installed:")
                  for hook_name, hook_path in HookManager().get_hook_paths().items():
                      exists = "✓" if hook_path.exists() else "✗"
                      print(f"  {exists} {hook_name}")
              else:
                  print("No hooks installed. Run 'waiting' to enable.")

              return 0
          except Exception as e:
              print(f"✗ Error: {e}", file=sys.stderr)
              self.logger.error(f"Status failed: {e}")
              return 1

      def show_help(self) -> int:
          """Show help message"""
          print("""
  Waiting - Audio notification for Claude Code permission dialogs

  Usage:
    waiting              Enable notifications (install hooks)
    waiting disable      Disable notifications (remove hooks)
    waiting status       Show current configuration
    waiting --help       Show this message

  Configuration:
    Edit ~/.waiting.json to customize:
    - grace_period: seconds to wait before bell (default: 30)
    - volume: bell volume 1-100 (default: 100)
    - audio: path to audio file or "default" (default: "default")

  More info: https://github.com/your-org/waiting
          """)
          return 0
  ```

#### 4.2: Main Entry Point
- **File:** `/home/michael/projects/waiting_new/src/waiting/__main__.py`
- **Implementation:**
  ```python
  import sys
  from .cli import CLI

  def main(args: list[str] | None = None) -> int:
      """Main entry point for CLI"""
      args = args or sys.argv[1:]
      cli = CLI()

      if not args or args[0] in ["--help", "-h", "help"]:
          return cli.show_help()

      command = args[0]

      if command == "enable":
          return cli.enable()
      elif command == "disable":
          return cli.disable()
      elif command == "status":
          return cli.status()
      else:
          print(f"Unknown command: {command}", file=sys.stderr)
          return cli.show_help()

  if __name__ == "__main__":
      sys.exit(main())
  ```

- **Update pyproject.toml:**
  ```toml
  [project.scripts]
  waiting = "waiting.__main__:main"
  ```

#### 4.3: CLI Tests
- **File:** `/home/michael/projects/waiting_new/tests/unit/test_cli.py`
- **Tests:**
  - Enable command creates config
  - Enable command installs hooks
  - Disable command removes hooks
  - Status command displays config
  - Invalid commands show help
  - Error handling

- **File:** `/home/michael/projects/waiting_new/tests/integration/test_cli.py`
- **Integration tests:**
  - Full enable/disable/status workflow
  - Config persists across commands
  - Hook installation verified by filesystem

- **Acceptance:**
  - `waiting` command works
  - `waiting status` displays config
  - `waiting disable` removes hooks
  - `waiting --help` shows help
  - All CLI tests pass

---

## Phase 5: Testing & QA (Week 5)

### Goals
- Comprehensive unit & integration test coverage
- Platform-specific testing
- Performance and reliability testing
- Documentation

### Tasks

#### 5.1: Unit Test Coverage
- **Target:** 80%+ code coverage
- **Test files to enhance:**
  - `tests/unit/test_config.py` - Config loading/validation
  - `tests/unit/test_state.py` - State management
  - `tests/unit/test_audio.py` - Audio playback
  - `tests/unit/test_audio_players.py` - Player implementations
  - `tests/unit/test_hooks.py` - Hook management
  - `tests/unit/test_cli.py` - CLI commands

- **Run coverage:**
  ```bash
  pytest --cov=src/waiting tests/unit/
  ```

#### 5.2: Integration Tests
- **Test hooks end-to-end:**
  - Simulate PermissionRequest hook
  - Verify grace period timer
  - Simulate user response via PreToolUse
  - Verify stop signal sent
  - Verify audio stopped
  - Verify cleanup

- **Test CLI workflows:**
  - Install → status → disable → status
  - Config modification between commands
  - Error scenarios

#### 5.3: Platform-Specific Testing
- **Linux (CI pipeline):**
  - Test all three audio players (paplay, pw-play, aplay)
  - Verify fallback chain
  - Test hook script execution

- **Manual testing (if available):**
  - macOS: Test afplay integration
  - Windows WSL: Test PowerShell integration

#### 5.4: Performance Testing
- **Test scenarios:**
  - Grace period timing accuracy (within 1 second)
  - Audio startup latency (< 500ms)
  - Stop signal detection latency (< 100ms)
  - State file cleanup under load (multiple rapid requests)

#### 5.5: Documentation
- **README.md:** Installation, usage, configuration
- **TROUBLESHOOTING.md:** Common issues and solutions
- **DEVELOPMENT.md:** How to contribute, run tests
- **Architecture.md:** System design overview (this document becomes reference)

---

## Testing Strategy

### Test-First Approach

For each feature, write tests before implementation:

1. **Unit tests** - Test isolated functions with mocks
2. **Integration tests** - Test component interactions
3. **System tests** - Test end-to-end workflows

### Test Structure

```python
# Example: test_config.py
import pytest
from pathlib import Path
from waiting.config import Config, load_config, save_config
from waiting.errors import ConfigError

class TestConfig:
    def test_default_config_values(self):
        """Config should have sensible defaults"""
        config = Config(grace_period=30, volume=100, audio="default")
        assert config.grace_period == 30
        assert config.volume == 100
        assert config.audio == "default"

    def test_validate_grace_period_positive(self):
        """Grace period must be positive"""
        config = Config(grace_period=-1, volume=100, audio="default")
        is_valid, error = config.validate()
        assert not is_valid
        assert "positive" in error.lower()

    def test_load_missing_config_creates_defaults(self, tmp_home):
        """Missing config should create defaults"""
        config = load_config(tmp_home / ".waiting.json")
        assert config.grace_period == 30
        assert config.volume == 100

    def test_save_and_load_config(self, tmp_path):
        """Config should persist to disk"""
        original = Config(grace_period=45, volume=80, audio="default")
        config_path = tmp_path / ".waiting.json"

        save_config(original, config_path)
        loaded = load_config(config_path)

        assert loaded.grace_period == 45
        assert loaded.volume == 80
```

### Mocking Strategy

- **Mock file I/O** for config tests
- **Mock subprocess** for audio player tests
- **Mock /tmp filesystem** for state tests
- **Mock Claude's hook JSON** for hook tests

### CI/CD Integration

```yaml
# .github/workflows/test.yml (reference)
- Run: pytest tests/unit/ --cov=src/waiting
- Run: pytest tests/integration/ -m "not slow"
- Check: Coverage >= 80%
```

---

## Technical Decisions & Trade-offs

### 1. Bash vs Python for Hook Scripts

**Decision: Bash** (for hook scripts only)

**Rationale:**
- Hooks must be lightweight and fast
- Bash is universally available
- Python subprocess overhead unnecessary for simple temp file I/O
- Bash easier to customize per platform

**Trade-off:** Less testable than Python, but core logic (audio playback) is in Python

### 2. Temp Files vs Database/Process State

**Decision: Temp files** (`/tmp/waiting-*.pid`, `/tmp/waiting-stop-*`)

**Rationale:**
- MVP requirement: zero external dependencies
- Temp files are atomic and cross-process safe
- Simple to debug (readable files)
- Self-cleaning (filesystem cleanup)

**Trade-off:** Not as efficient as in-memory state, but sufficient for MVP

**Alternative rejected:** In-memory daemon - would require process persistence across hooks, more complex

### 3. Single Grace Period vs Multiple Triggers

**Decision: Single grace period** for MVP

**Rationale:**
- User stories scope MVP to PermissionRequest hook only
- Simpler state management (one timer per session)
- Future: Can add `stop` and `idle` hooks in Phase 2

**Trade-off:** Can't chain notifications, but user stories explicitly exclude this for MVP

### 4. Audio Player Selection Strategy

**Decision: Fallback chain per-platform** (paplay → pw-play → aplay on Linux)

**Rationale:**
- Users have different audio systems installed
- Graceful degradation if preferred player unavailable
- Each player tested independently

**Alternative rejected:** User configuration of player - adds complexity, fallback chain sufficient

### 5. Configuration File Format

**Decision: JSON** (`~/.waiting.json`)

**Rationale:**
- Human-editable
- No external parser dependencies (Python built-in json)
- Bash scripts can parse with jq (commonly available)

**Alternative rejected:** YAML (requires pyyaml dependency)

### 6. Logging

**Decision: File-based** (`~/.waiting.log`)

**Rationale:**
- Visible to user for debugging
- No impact on Claude Code output
- Simple rotation/cleanup

**Alternative rejected:** syslog (not cross-platform), stdout (interferes with Claude)

### 7. Session ID Generation

**Decision: Fallback from JSON → MD5 hash**

**Rationale:**
- Claude Code may not provide session ID in hook JSON
- MD5(hostname + timestamp) is unique enough for MVP
- Deterministic but not cryptographic

**Alternative rejected:** UUID (overkill), simple incrementing counter (not unique across reboots)

---

## Dependency Analysis

### Runtime Dependencies
**NONE** - MVP is zero-dependency Python package

### Development Dependencies
- **pytest** - Testing framework
- **pytest-cov** - Coverage reporting

### External Commands (Soft Dependencies)
- **Linux:** `paplay`, `pw-play`, `aplay` (at least one required)
- **macOS:** `afplay` (included by default)
- **Windows:** PowerShell (included by default)
- **Bash:** `jq` (optional, fallback to manual parsing)

### Why Zero Dependencies?
- Simpler installation (`pip install -e .`)
- Fewer security concerns
- Faster import time
- Easier to debug

---

## File Structure with Content Outline

```
src/waiting/
├── __init__.py
│   └── Version, __all__ declarations
├── __main__.py
│   └── CLI entry point, main()
├── cli.py
│   └── CLI class with enable/disable/status/help
├── config.py
│   └── Config dataclass, load_config(), save_config()
├── errors.py
│   └── WaitingError, ConfigError, HookError, AudioError
├── logging.py
│   └── setup_logging() function
├── state.py
│   └── Session management, temp file helpers
├── audio.py
│   └── play_audio(), kill_audio(), platform detection
├── audio_players/
│   ├── __init__.py
│   ├── base.py
│   │   └── AudioPlayer protocol
│   ├── linux.py
│   │   └── PulseAudioPlayer, PipeWirePlayer, ALSAPlayer
│   ├── macos.py
│   │   └── AFPlayPlayer
│   └── windows.py
│       └── PowerShellPlayer
└── hooks/
    ├── __init__.py
    ├── manager.py
    │   └── HookManager class
    └── scripts/
        ├── waiting-notify-permission.sh
        └── waiting-activity-tooluse.sh

tests/
├── conftest.py
│   └── Pytest fixtures
├── unit/
│   ├── test_config.py
│   ├── test_state.py
│   ├── test_audio.py
│   ├── test_audio_players.py
│   ├── test_hooks.py
│   └── test_cli.py
└── integration/
    ├── test_cli.py
    ├── test_hook_lifecycle.py
    └── test_audio_playback.py
```

---

## Implementation Checklist

### Phase 1: Foundation
- [ ] Update pyproject.toml with CLI entry point
- [ ] Create errors.py with custom exceptions
- [ ] Create logging.py with setup_logging()
- [ ] Create config.py with Config class and load/save functions
- [ ] Create state.py with session ID and temp file helpers
- [ ] Create settings.py with ~/.claude/settings.json integration (CRITICAL FOR HOOKS)
- [ ] Create tests/conftest.py with pytest fixtures
- [ ] Create pytest.ini
- [ ] Create tests/unit/test_config.py
- [ ] Create tests/unit/test_state.py
- [ ] Create tests/unit/test_settings.py
- [ ] All Phase 1 unit tests passing

### Phase 2: Hooks & Events
- [ ] Create hooks/manager.py with HookManager class
- [ ] Create hooks/scripts/waiting-notify-permission.sh
- [ ] Create hooks/scripts/waiting-activity-tooluse.sh
- [ ] Create tests/unit/test_hooks.py
- [ ] Create tests/integration/test_hook_lifecycle.py
- [ ] All Phase 2 tests passing

### Phase 3: Audio Playback
- [ ] Create audio_players/base.py with AudioPlayer protocol
- [ ] Create audio_players/linux.py with three Linux players
- [ ] Create audio_players/macos.py with AFPlayPlayer
- [ ] Create audio_players/windows.py with PowerShellPlayer
- [ ] Create audio.py with main audio interface
- [ ] Create tests/unit/test_audio.py
- [ ] Create tests/unit/test_audio_players.py
- [ ] Create tests/integration/test_audio_playback.py
- [ ] All Phase 3 tests passing

### Phase 4: CLI Commands
- [ ] Create cli.py with CLI class
- [ ] Create __main__.py with main() entry point
- [ ] Update pyproject.toml with [project.scripts]
- [ ] Create tests/unit/test_cli.py
- [ ] Create tests/integration/test_cli.py
- [ ] All Phase 4 tests passing
- [ ] `waiting` command works end-to-end

### Phase 5: Testing & QA
- [ ] Achieve 80%+ test coverage
- [ ] Run full integration test suite
- [ ] Manual testing on Linux
- [ ] Document any platform-specific issues
- [ ] Write README.md
- [ ] Write TROUBLESHOOTING.md
- [ ] All tests passing

---

## Commit Strategy

**Small, focused commits** per AGENTS.md rules:

```
Phase 1 Commits:
- feat: add project structure with errors and logging modules
- feat: add Config dataclass and config management
- feat: add state management with temp file helpers
- test: add pytest fixtures and test framework

Phase 2 Commits:
- feat: add HookManager for hook installation/removal
- feat: add PermissionRequest hook script template
- feat: add PreToolUse hook script template
- test: add comprehensive hook lifecycle tests

Phase 3 Commits:
- feat: add AudioPlayer protocol and Linux implementations
- feat: add macOS and Windows audio player implementations
- feat: add audio.py with platform detection and playback
- test: add audio player and platform-specific tests

Phase 4 Commits:
- feat: add CLI class with enable/disable/status commands
- feat: add __main__.py entry point and command dispatch
- test: add CLI unit and integration tests

Phase 5 Commits:
- test: achieve 80%+ code coverage on all modules
- docs: add README, TROUBLESHOOTING, DEVELOPMENT guides
- ci: add GitHub Actions workflow for testing
```

---

## Risk Mitigation

| Risk | Mitigation |
|------|-----------|
| Hook scripts fail silently | Comprehensive logging to ~/.waiting.log |
| Audio player not available | Fallback chain + graceful degradation + status command |
| Temp files accumulate | Auto-cleanup of files > 1 hour old |
| Config validation errors | Clear error messages + validation in status command |
| Cross-platform issues | Test on Linux CI, manual test on macOS/WSL |
| State file race conditions | Atomic file operations (create, check existence) |

---

## Success Criteria

### MVP Complete When:
1. All user stories (US-1 through US-22) have passing tests
2. `waiting` command installs/enables/disables hooks correctly
3. `waiting status` shows accurate configuration
4. Audio plays after grace period on PermissionRequest
5. Audio stops when user responds (PreToolUse hook)
6. Works on Linux with paplay/pw-play/aplay fallback
7. Manual testing on macOS confirms afplay integration
8. Manual testing on WSL confirms PowerShell fallback
9. 80%+ unit test coverage
10. README and TROUBLESHOOTING documented
11. All code follows functional style with strict type hints
12. Codebase is zero-dependency (except dev dependencies)

---

## Next Steps

1. **Week 1:** Implement Phase 1 (Foundation) - Project structure, config, state, tests
2. **Week 2:** Implement Phase 2 (Hooks) - Hook manager, Bash scripts, hook tests
3. **Week 3:** Implement Phase 3 (Audio) - Audio players, platform detection, integration
4. **Week 4:** Implement Phase 4 (CLI) - Command handlers, CLI integration
5. **Week 5:** Implement Phase 5 (QA) - Test coverage, documentation, manual testing

Each week's work should be broken into small, committed changes.

---

## Critical Updates from Official Hook Specs (info.md)

This implementation plan has been refined based on review of the official Claude Code hooks reference documentation. Key findings:

### 1. Hook Registration MUST Go to ~/.claude/settings.json
- **Original Plan:** Only generate hook scripts to ~/.claude/hooks/
- **Updated Plan:** HookManager must also register hooks in ~/.claude/settings.json
- **Impact:** Phase 1 now includes `settings.py` module for settings file management
- **Impact:** Phase 2 HookManager is updated to write both scripts AND settings registration

### 2. Hook Input/Output Format Clarified
- **Input:** Hooks receive JSON via stdin with standard fields: `session_id`, `transcript_path`, `cwd`, `permission_mode`, `hook_event_name`
- **session_id:** Available in hook input per official spec (line 492)
- **Output:** Exit code 0 + optional JSON for structured responses
- **Exit code 2:** Blocking error (stderr shown to Claude)
- **Updated:** Hook scripts now explicitly parse `session_id` from official hook JSON input

### 3. Hook Event Flow Clarified
- **PermissionRequest:** Fires when permission dialog shown
- **PreToolUse:** Fires BEFORE ANY tool execution (every Read, Write, Edit, Bash, etc.)
- **Coordination:** PreToolUse running = user is responding to permission request
- **Updated:** Documentation now clarifies this is the correct interpretation

### 4. Bash Script Exit Behavior
- **Original:** Scripts should exit immediately for non-blocking behavior
- **Confirmed:** Background processes (&) are correct approach for grace period timer
- **Important:** Hook process itself must exit 0 quickly; grace period/audio runs in subshell

### 5. Future Enhancement: Notification Event
- **Discovered:** Official specs mention `Notification` hook with matchers: `permission_prompt`, `idle_prompt`, `auth_success`, etc. (line 348+)
- **Observation:** Could use `idle_prompt` matcher for idle notifications (future work, Phase 6+)
- **Current MVP:** Focuses only on PermissionRequest event

### 6. Dependencies
- **jq:** Used in bash scripts for JSON parsing (commonly available, soft dependency)
- **Graceful Degradation:** Scripts test for jq availability, fall back to defaults if missing

### 7. Settings File Integration (NEW)
- **Critical:** settings.py module must:
  - Load ~/.claude/settings.json
  - Merge waiting hooks without overwriting other hooks
  - Save settings back cleanly
  - Handle missing settings file gracefully
- **Test Coverage:** Must verify existing hooks are preserved during merge/remove

---

## Questions for Product Manager

1. **Nag/Repeat alerts:** Should the bell repeat if user still hasn't responded? (Currently scoped out of MVP)
2. **Idle Notifications:** Interest in using `Notification` hook with `idle_prompt` to notify when Claude waiting for input? (Currently Phase 6+ future work)
3. **Multiple Hooks:** Plan to support `stop` and `idle` hooks beyond PermissionRequest? (Currently scoped out of MVP)
4. **Web UI:** Any interest in web-based configuration in the future, or CLI-only?
5. **Analytics:** Track usage metrics (how often alerts fire, stop signal latency)?

